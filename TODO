# Known Bugs:

   - Bug ->go or ->visit causes actions which have Args or CaptureArgs called
     twice when called via ->go or ->visit.

     Test app: http://github.com/bobtfish/catalyst-app-bug-go_chain/tree/master

# Compatibility warnings to add:

  - $self->config should warn as config should only ever be called as a
    class method (TESTS).

# Proposed functionality / feature additions:

## Log setup needs to be less lame

So Catalyst::Plugin::Log::* can die
in a fire. Having $c->log_class would be a good start. kane volunteered
to do some of this.

Simple example: Catalyst::Plugin::Log::Colorful should just be a
subclass of Catalyst::Log, no ::Plugin:: needed.

See also: Catalyst::Plugin::Log::Dispatch and
http://github.com/willert/catalyst-plugin-log4perl-simple/tree

# REFACTORING

##  The horrible hack for plugin setup - replacing it:

 * Have a look at the Devel::REPL BEFORE_PLUGIN stuff
   I wonder if what we need is that combined with plugins-as-roles

## App / ctx split:

  NOTE - these are notes that t0m thought up after doing back compat for
         catalyst_component_class, may be inaccurate, wrong or missing things
         bug mst (at least) to correct before trying more than the first 2
         steps. Please knock yourself out on the first two however :)

  - Eliminate actions in MyApp from the main test suite
  - Uncomment warning in C::C::register_action_methods, add tests it works
    by mocking out the logging..
  - Remove MyApp @ISA controller (ask metaclass if it has attributes, and if
                                  so you need back compat :/)
  - Make Catalyst::Context, move the per request stuff in there, handles from
    main app class to delegate
  - Make an instance of the app class which is a global variable
  - Make new instance of the context class, not the app class per-request
  - Remove the components as class data, move to instance data on the app
    class (you probably have to do this for _all_ the class data, good luck!)
  - Make it possible for users to spin up different instances of the app class
    (with different config etc each)
  - Profit! (Things like changing the complete app config per vhost, i.e.
    writing a config loader / app class role which dispatches per vhost to
    differently configured apps is piss easy)

## GSOC

### Next large steps, planned:

For all components that have been discovered, in whatever way, we create a service:
 - that's a catalyst component service
 - which is basically just a constructor injection
 - except the constructor name is COMPONENT
 - and we're "implicitly" passing along some constructor args
 - Lifecycle => Singleton

 - Fix B::B so that Service::WithParametrs' parameters attribute has a builder
 - Fix ConstructorInjection so that default parameters are supplied (for accept_context_args)
 - Fix ConstructorInjection's 'suffix' - should be called 'config_key' or something, and
   should be an attribute on the service (as it never changes), rather than a parameter
   to the service 

 - We make a 'components' sub container in the main container.
   - This gets the ConstructorInjection COMPONENT services, as model_Foo.
   - Lifecycle of these services is Singleton
   - This simplifies the code for MyApp->components, as it need only list one sub-container

 - We create a second service (depending on the first one) for ACCEPT_CONTEXT
   - This has a custom service which calls ACCEPT_CONTEXT when the instance is fetched
   - Not Singleton lifecycle
 
   Note - ACCEPT_CONTEXT can be called on app values - if you have a Model::Foo, with an ACCEPT_CONTEXT
   and you call MyApp->model('Foo') then ACCEPT_CONTEXT gets invoked with a $c of 'MyApp' (this is not\
   the normal case, but we need to preserve for compat)

### Next steps - less planned:

  - Creating service()-like sugar for component

  - Test cases for extending the container in an application.
    - Using the sugar added in the previous item
    - Test when Model::Foo depends_on Model::Bar


#### Extending my app, notes

Basically try to implement something like this (starting out without the sugar!), and see how it breaks
and what needs to be done to fix it!

##### Eventual syntax

package MyApp::Container;
use Catalyst::IOC;
    
    container $self, as { 
            container model => as {
                component Foo => (); # As per default!
                component Bar => (dependencies => ['/model/Foo']); # Magic!
                component Baz => ( lifecycle => 'InstancePerContext );
                component Quux => ( lifecycle => 'Singleton' ); # ACCEPT_CONTEXT not called
            };                    
            # Note - implementation of BB may need to be changed to support making sure existing 
            # services actually get overridden. not sure how the default container behaves when doing that
            # above code would build the constructor injection as it currently does,
            # defaulting to the class name in the right namespace as declared by the surrounding container
            # as well as adding using the catalyst-specific service class
    };

1;

##### To start with

package MyApp::Container;
use Moose;

extends 'Catalyst::Container;

after BUILD => sub {
    my $self = shift;
    my $model_container = $self->get_sub_container('model');
    my $service = Catalyst::IOC::ConstructorInjection->new(
        name      => 'Baz',
        class     => 'MyApp::Model::Baz',
        dependencies => [
            depends_on( '/application_name' ),
            depends_on( '/config' ),
            depends_on( '/model/Foo' ),
        ],
        lifecycle => 'InstancePerContext',
    );
    $model_container->add_service( 'Foo', $service );
};

### To polish off / t0m review

    +Same as L<build_model_subcontainer>, but for controllers. The difference is
    +that there is no ACCEPT_CONTEXT for controllers.
    ^^ This is wrong!!
    
    -    my $accept_context_args = $self->param('accept_context_args');
    +    my $accept_context_args = $params{accept_context_args};
    ^^ This (may be) wrong! I am thinking the service should be allowed to mangle the 
       accept_context args, no?
       Without this change, the user could make a custom service which mangled the param, and use 
       Catalyst/IOC/Service/WithAcceptContext.pm, with this change, that module will always see the
       un-mangled version?? However, without this change, shit doesn't work...

### Known issues

    - Broken $instance->expand_modules() in setup_components and figure
      out later how to bring it back

    - expand_component_module

    - People wrapping locate_components in Catalyst.pm
