# Known Bugs:

   - Bug ->go or ->visit causes actions which have Args or CaptureArgs called
     twice when called via ->go or ->visit.

     Test app: http://github.com/bobtfish/catalyst-app-bug-go_chain/tree/master

# Compatibility warnings to add:

  - $self->config should warn as config should only ever be called as a
    class method (TESTS).

# Proposed functionality / feature additions:

## Log setup needs to be less lame

So Catalyst::Plugin::Log::* can die
in a fire. Having $c->log_class would be a good start. kane volunteered
to do some of this.

Simple example: Catalyst::Plugin::Log::Colorful should just be a
subclass of Catalyst::Log, no ::Plugin:: needed.

See also: Catalyst::Plugin::Log::Dispatch and
http://github.com/willert/catalyst-plugin-log4perl-simple/tree

# REFACTORING

##  The horrible hack for plugin setup - replacing it:

 * Have a look at the Devel::REPL BEFORE_PLUGIN stuff
   I wonder if what we need is that combined with plugins-as-roles

## App / ctx split:

  NOTE - these are notes that t0m thought up after doing back compat for
         catalyst_component_class, may be inaccurate, wrong or missing things
         bug mst (at least) to correct before trying more than the first 2
         steps. Please knock yourself out on the first two however :)

  - Eliminate actions in MyApp from the main test suite
  - Uncomment warning in C::C::register_action_methods, add tests it works
    by mocking out the logging..
  - Remove MyApp @ISA controller (ask metaclass if it has attributes, and if
                                  so you need back compat :/)
  - Make Catalyst::Context, move the per request stuff in there, handles from
    main app class to delegate
  - Make an instance of the app class which is a global variable
  - Make new instance of the context class, not the app class per-request
  - Remove the components as class data, move to instance data on the app
    class (you probably have to do this for _all_ the class data, good luck!)
  - Make it possible for users to spin up different instances of the app class
    (with different config etc each)
  - Profit! (Things like changing the complete app config per vhost, i.e.
    writing a config loader / app class role which dispatches per vhost to
    differently configured apps is piss easy)

## GSOC

### Next large steps:

  - Moving setup_components etc into the container

    - Move setup_components down into the container (setup_components becomes a one or two line method in Catalyst.pm)

    - refactor / cleanup setup_component

    - Move locate_components

    - Move contents of setup_components

  - Finished documentation for ::IOC parts.

  - Creating service()-like sugar for component

  - Test cases for extending the container in an application.
    - Using the sugar added in the previous item
    - Test when Model::Foo depends_on Model::Bar

  - Allowing people to change component lifecycles

     role Service::WithAcceptContext {}
     role Service::WithCOMPONENT {}
     class Service::CatalystComponent extends Service with (WithAcceptContext, WithCOMPONENT) {}

    a) configure additional services in that container 
        -  super simple container $default_container => as { more services };
        class MyApp::Container extends Catalyst::Container {
            use Bread::Board; # Or our own sugar?
            method BUILD { container $self => as { 
                    service model => ...; # some constructor injection to MyApp::Model or something
                    container Model => as {
                        component Foo => (dependencies => ['/model']); # As per default!
                        component Bar => (dependencies => ['/model/Foo']); # Magic!
                    };
                    # Note - implementation of BB may need to be changed to support making sure existing 
                    # services actually get overridden. not sure how the default container behaves when doing that
                    # above code would build the constructor injection as it currently does,
                    # defaulting to the class name in the right namespace as declared by the surrounding container
                    # as well as adding using the catalyst-specific service class
            } }
        };
    b) make component services depend on that, and 


    c) ask for those 
              services declared in a) outside of a web context
       simple as well. $customised_container->fetch('service')->get # or whatever the api was

19:23 < andrewalker> edenc, when explaining to me how it should be, drafted this: https://gist.github.com/1098186
19:26 < edenc> I like the possibility of being able to provide a backwards-compatible structure which we can muck around with by configuring B::B
19:26 <@rafl> so, the request context clearly isn't a service
19:27 <@rafl> but that's ok. there's parametrised services
19:27 < edenc> yeah, that was a draft
19:27 <@rafl> the outer Foo service is pretty much what i'd expect Service::WithAcceptContext to do, except with a dependency on a context instead of a service parameter
19:32 <@rafl> actually having services for the pre-ACCEPT_CONTEXT bits is what i want to think about

### To polish off

  - Document current methods
  - +    $class->container->get_sub_container('model')->make_single_default;
+    $class->container->get_sub_container('view')->make_single_default;

### Known issues

    - Broken $instance->expand_modules() in setup_components and figure
      out later how to bring it back

    - expand_component_module

